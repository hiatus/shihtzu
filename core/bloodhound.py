#!/usr/bin/env python3

from datetime import datetime
from io import DEFAULT_BUFFER_SIZE
import json
import os
import re


RE_BH_FILE_USERS = r'.*_users(_(0[1-9]|[1-9][0-9]))?\.json'
RE_BH_FILE_COMPUTERS = r'.*_computers(_(0[1-9]|[1-9][0-9]))?\.json'
RE_BH_FILE_GROUPS = r'.*_groups(_(0[1-9]|[1-9][0-9]))?\.json'


class DomainUser:
    SEARCH_PROPERTIES = [
        'objectid', 'enabled', 'domain', 'samaccountname', 'distinguishedname', 'displayname',
        'description', 'email'
    ]

    DEFAULT_SEARCH_PROPERTIES = ['objectid', 'samaccountname', 'description', 'displayname']

    def __init__(self, data: dict, search_properties=DEFAULT_SEARCH_PROPERTIES):
        properties = data['Properties']
        properties['objectid'] = data.get('ObjectIdentifier', '')

        self.json = json.dumps(data)
        self.object_id = properties.get('objectid') or ''
        self.enabled = properties.get('enabled') or False
        self.domain = properties.get('domain') or ''
        self.sam_account_name = properties.get('samaccountname') or ''
        self.distinguished_name = properties.get('distinguishedname') or ''
        self.spns = properties.get('serviceprincipalnames', [])
        self.pwd_never_expires = properties.get('pwdneverexpires') or False
        self.dont_req_preauth = properties.get('dontreqpreauth') or False
        self.unix_password = properties.get('unixpassword') or ''
        self.display_name = properties.get('displayname') or ''
        self.description = properties.get('description') or ''
        self.email = properties.get('email') or ''

        self.creation_date = self.last_logon = self.pwd_last_set = ''

        if properties.get('whencreated'):
            self.creation_date = datetime.fromtimestamp(properties.get('whencreated', 0))

        if properties.get('lastlogon'):
            self.last_logon = datetime.fromtimestamp(properties.get('lastlogon', 0))

        if properties.get('pwdlastset'):
            self.pwd_last_set = datetime.fromtimestamp(properties.get('pwdlastset', 0))

        self.search_string = '\n'.join(
            [properties.get(sp) or '' for sp in search_properties]
        ).lower()

    def __str__(self):
        return (
            f'              Object ID : {self.object_id}\n'
            f'                Enabled : {self.enabled}\n'
            f'                 Domain : {self.domain}\n'
            f'       SAM Account Name : {self.sam_account_name}\n'
            f'     Distinguished Name : {self.distinguished_name}\n'
            f'          Creation Date : {self.creation_date}\n'
            f'             Last Logon : {self.last_logon}\n'
            f'      Password Last Set : {self.pwd_last_set}\n'
            f' Password Never Expires : {self.pwd_never_expires}\n'
            f'          Unix Password : {self.unix_password}\n'
            f'           Display Name : {self.display_name}\n'
            f'            Description : {self.description}\n'
            f'                  Email : {self.email}\n'
            f"Service Principal Names : {', '.join(self.spns)}"
        )

    # The `bh_path` variable holds the path to the folder containing the *.json files generated by
    # Bloodhound.
    @classmethod
    def load_files(cls, bh_path='.', search_properties=DEFAULT_SEARCH_PROPERTIES):
        bh_files = []

        for fn in os.listdir(bh_path):
            if re.match(RE_BH_FILE_USERS, fn):
                bh_files.append(fn)

        if not bh_files:
            raise RuntimeError('No BloodHound users files were found.')

        for path in bh_files:
            with open(path, 'rt') as fo:
                users = json.loads(fo.read())

            for u in users['data']:
                yield cls(u, search_properties=search_properties)

    def matches_term(self, search_term: str) -> bool:
        return True if search_term in self.search_string else False


class DomainComputer:
    SEARCH_PROPERTIES = [
        'objectid', 'domain', 'samaccountname', 'distinguishedname', 'name'
        'description', 'operating_system'
    ]

    DEFAULT_SEARCH_PROPERTIES = ['objectid', 'samaccountname', 'description', 'name']

    def __init__(self, data: dict, search_properties=DEFAULT_SEARCH_PROPERTIES):
        properties = data['Properties']
        properties['objectid'] = data.get('ObjectIdentifier', '')

        self.json = json.dumps(data)
        self.object_id = properties.get('objectid') or ''
        self.enabled = properties.get('enabled') or False
        self.domain = properties.get('domain') or ''
        self.sam_account_name = properties.get('samaccountname') or ''
        self.distinguished_name = properties.get('distinguishedname') or ''
        self.spns = properties.get('serviceprincipalnames', [])
        self.has_laps = properties.get('haslaps') or False
        self.name = properties.get('name') or ''
        self.description = properties.get('description') or ''
        self.operating_system = properties.get('operating_system') or ''

        self.creation_date = self.last_logon = self.pwd_last_set = ''

        if properties.get('whencreated'):
            self.creation_date = datetime.fromtimestamp(properties.get('whencreated', 0))

        if properties.get('lastlogon'):
            self.last_logon = datetime.fromtimestamp(properties.get('lastlogon', 0))

        if properties.get('pwdlastset'):
            self.pwd_last_set = datetime.fromtimestamp(properties.get('pwdlastset', 0))

        self.search_string = '\n'.join(
            [properties.get(sp, '') for sp in search_properties]
        ).lower()

    def __str__(self):
        return (
            f'              Object ID : {self.object_id}\n'
            f'                Enabled : {self.enabled}\n'
            f'                 Domain : {self.domain}\n'
            f'       SAM Account Name : {self.sam_account_name}\n'
            f'     Distinguished Name : {self.distinguished_name}\n'
            f'          Creation Date : {self.creation_date}\n'
            f'             Last Logon : {self.last_logon}\n'
            f'      Password Last Set : {self.pwd_last_set}\n'
            f'               Has LAPS : {self.has_laps}\n'
            f'                   Name : {self.name}\n'
            f'            Description : {self.description}\n'
            f'       Operating System : {self.operating_system}\n'
            f"Service Principal Names : {', '.join(self.spns)}"
        )

    # The `bh_path` variable holds the path to the folder containing the *.json files generated by
    # Bloodhound.
    @classmethod
    def load_files(cls, bh_path='.', search_properties=DEFAULT_SEARCH_PROPERTIES):
        bh_files = []

        for fn in os.listdir(bh_path):
            if re.match(RE_BH_FILE_COMPUTERS, fn):
                bh_files.append(fn)

        if not bh_files:
            raise RuntimeError('No BloodHound computers files were found.')

        for path in bh_files:
            with open(path, 'rt') as fo:
                computers = json.loads(fo.read())

            for c in computers['data']:
                yield cls(c, search_properties=search_properties)

    def matches_term(self, search_term: str) -> bool:
        return True if search_term in self.search_string else False


class DomainGroup:
    SEARCH_PROPERTIES = [
        'objectid', 'domain', 'samaccountname', 'distinguishedname', 'name'
        'description'
    ]

    DEFAULT_SEARCH_PROPERTIES = ['objectid', 'samaccountname', 'description', 'name']

    def __init__(self, data: dict, search_properties=DEFAULT_SEARCH_PROPERTIES):
        properties = data['Properties']
        properties['objectid'] = data.get('ObjectIdentifier', '')

        self.json = json.dumps(data)
        self.object_id = properties.get('objectid') or ''
        self.domain = properties.get('domain') or ''
        self.sam_account_name = properties.get('samaccountname') or ''
        self.distinguished_name = properties.get('distinguishedname') or ''
        self.name = properties.get('name') or ''
        self.description = properties.get('description') or ''
        self.member_object_ids = [m['ObjectIdentifier'] for m in data.get('Members', [])]

        self.creation_date = ''

        if properties.get('whencreated'):
            self.creation_date = datetime.fromtimestamp(properties.get('whencreated', 0))

        self.search_string = '\n'.join(
            [properties.get(sp, '') for sp in search_properties]
        ).lower()

    def __str__(self):
        return (
            f'         Object ID : {self.object_id}\n'
            f'            Domain : {self.domain}\n'
            f'  SAM Account Name : {self.sam_account_name}\n'
            f'Distinguished Name : {self.distinguished_name}\n'
            f'     Creation Date : {self.creation_date}\n'
            f'              Name : {self.name}\n'
            f'       Description : {self.description}\n'
            f'      Member Count : {len(self.member_object_ids)}'
        )

    # The `bh_path` variable holds the path to the folder containing the *.json files generated by
    # Bloodhound.
    @classmethod
    def load_files(cls, bh_path='.', search_properties=DEFAULT_SEARCH_PROPERTIES):
        bh_files = []

        for fn in os.listdir(bh_path):
            if re.match(RE_BH_FILE_GROUPS, fn):
                bh_files.append(fn)

        if not bh_files:
            raise RuntimeError('No BloodHound groups files were found.')

        for path in bh_files:
            with open(path, 'rt') as fo:
                groups = json.loads(fo.read())

            for g in groups['data']:
                yield cls(g, search_properties=search_properties)

    def matches_term(self, search_term: str) -> bool:
        return True if search_term in self.search_string else False

    def contains(self, object_id: str):
        return True if object_id in self.member_object_ids else False

